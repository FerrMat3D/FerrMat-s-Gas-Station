/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef,useEffect  } from "react";
import { useGLTF } from "@react-three/drei";

import * as THREE from 'three';
import { ShaderMaterial } from 'three';


export function Letters(props) {
  const { nodes, materials } = useGLTF("/Letters.glb");



  const material = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(0, 20, 0) },
      colorEnd: { value: new THREE.Vector3(0, 1, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time;

    void main() {
      vec3 color = step(fract(time), 0.5) * vec3(0, 20, 0); // Altere aqui a cor desejada
      gl_FragColor = vec4(color, 1.0);
    }
  `,
  });


  const material2 = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(10, 0, 10) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time; // Um valor entre 0 e 1 controlando a transição
uniform vec3 colorStart; // Cor inicial [10, 0, 10]
uniform vec3 colorEnd; // Cor final [1, 0, 1]

void main() {
  // Use a função sin para criar uma transição suave com fade in e fade out
  float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);

  // Interpole entre as cores de início e fim com base na transição
  vec3 color = mix(colorStart, colorEnd, transition);

  gl_FragColor = vec4(color, 1.0);
}
  `,
  });

  const currentTimeRef = useRef(0);

  const currentTimeRef2 = useRef(0);


  useEffect(() => {
    let animationFrameId;
  
    const updateMaterialTime = () => {
      const time = (performance.now() % 1500) / 1500;
      currentTimeRef.current = time;
      material.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };
  
    updateMaterialTime();
  
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [material]);


  useEffect(() => {
    let animationFrameId;

    const updateMaterialTime = () => {
      const time = (performance.now() % 3000) / 3000;
      currentTimeRef2.current = time;
      material2.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };

    updateMaterialTime();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  },  [material2]); // Executa apenas uma vez ao montar o componente

  


  return (
    <group {...props} dispose={null}>
      <group
        position={[-10.23605442, 15.85700607, 0.01962805]}
        rotation={[Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.55090892, 0.2171011, 0.55090892]}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Ferreira.geometry}
          material={materials.black}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Ferreira_1.geometry}
          material={materials.glow}
        >

<meshStandardMaterial color={[0, 247/30, 255/30]} toneMapped={false} />

        </mesh>



      </group>
      <group
        position={[-10.23869705, 19.12203217, 0.25614524]}
        rotation={[Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.96579289, 0.61198336, 0.96579289]}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Text001.geometry}
          material={materials["Material.020"]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Text001_1.geometry}
          material={materials.bloomgas}
        >
<meshStandardMaterial color={[20, 0, 0]} toneMapped={false} />

        </mesh>
      </group>
      <group
        position={[-10.23865986, 17.57687569, -0.09036662]}
        rotation={[Math.PI / 2, 0, Math.PI / 2]}
        scale={[0.89669132, 0.56819654, 0.89669132]}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Text003.geometry}
          material={materials["Material.020"]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Text003_1.geometry}
          material={material}
        >


        </mesh>
      </group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.crystal_leds.geometry}
        material={material2}
        position={[-10.20867634, 17.04499435, 0.01382935]}
        scale={[0.68918037, 2.24410939, 3.00628138]}
      >



      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.crystal_extr.geometry}
        material={materials.stell}
        position={[-10.20867634, 17.04499435, 0.01382935]}
        scale={[0.68918037, 2.24410939, 3.00628138]}
      />
    </group>
  );
}

useGLTF.preload("./Letters.glb");
