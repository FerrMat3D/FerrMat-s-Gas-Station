/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect  } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { ShaderMaterial } from "three";

export function Chargers(props) {
  const { nodes, materials } = useGLTF("./Chargers.glb");



  const material = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(0, 5, 3) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time; // Um valor entre 0 e 1 controlando a transição
uniform vec3 colorStart; // Cor inicial [10, 0, 10]
uniform vec3 colorEnd; // Cor final [1, 0, 1]

void main() {
  // Use a função sin para criar uma transição suave com fade in e fade out
  float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);

  // Interpole entre as cores de início e fim com base na transição
  vec3 color = mix(colorStart, colorEnd, transition);

  gl_FragColor = vec4(color, 1.0);
}
  `,
  });


  const currentTimeRef = useRef(0);

  useEffect(() => {
    let animationFrameId;

    const updateMaterialTime = () => {
      const time = (performance.now() % 100) / 1000;
      currentTimeRef.current = time;
      material.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };

    updateMaterialTime();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  },  [material]); // Executa apenas uma vez ao montar o componente


  const materialcharger = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(3, 3, 0) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time; // Um valor entre 0 e 1 controlando a transição
uniform vec3 colorStart; // Cor inicial [10, 0, 10]
uniform vec3 colorEnd; // Cor final [1, 0, 1]

void main() {
  // Use a função sin para criar uma transição suave com fade in e fade out
  float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);

  // Interpole entre as cores de início e fim com base na transição
  vec3 color = mix(colorStart, colorEnd, transition);

  gl_FragColor = vec4(color, 1.0);
}
  `,
  });


  

  useEffect(() => {
    let animationFrameId;

    const updateMaterialTime = () => {
      const time = (performance.now() % 100) / 1000;
      currentTimeRef.current = time;
      materialcharger.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };

    updateMaterialTime();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  },  [materialcharger]); // Executa apenas uma vez ao montar o componente


  
  const materiallight = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(0, 8, 0) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time; // Um valor entre 0 e 1 controlando a transição
uniform vec3 colorStart; // Cor inicial [10, 0, 10]
uniform vec3 colorEnd; // Cor final [1, 0, 1]

void main() {
  // Use a função sin para criar uma transição suave com fade in e fade out
  float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);

  // Interpole entre as cores de início e fim com base na transição
  vec3 color = mix(colorStart, colorEnd, transition);

  gl_FragColor = vec4(color, 1.0);
}
  `,
  });




  useEffect(() => {
    let animationFrameId;

    const updateMaterialTime = () => {
      const time = (performance.now() % 1000) / 1000;
      currentTimeRef.current = time;
      materiallight.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };

    updateMaterialTime();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  },  [materiallight]); // Executa apenas uma vez ao montar o componente


  const materiallight2 = new ShaderMaterial({
    uniforms: {
      colorStart: { value: new THREE.Vector3(5, 5, 5) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 }, // Inicialmente, o tempo é 0
    },
    vertexShader:  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
    fragmentShader: `
    uniform float time; // Um valor entre 0 e 1 controlando a transição
uniform vec3 colorStart; // Cor inicial [10, 0, 10]
uniform vec3 colorEnd; // Cor final [1, 0, 1]

void main() {
  // Use a função sin para criar uma transição suave com fade in e fade out
  float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);

  // Interpole entre as cores de início e fim com base na transição
  vec3 color = mix(colorStart, colorEnd, transition);

  gl_FragColor = vec4(color, 1.0);
}
  `,
  });




  useEffect(() => {
    let animationFrameId;

    const updateMaterialTime = () => {
      const time = (performance.now() % 100) / 1000;
      currentTimeRef.current = time;
      materiallight2.uniforms.time.value = time;
      animationFrameId = requestAnimationFrame(updateMaterialTime);
    };

    updateMaterialTime();

    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  },  [materiallight2]); // Executa apenas uma vez ao montar o componente


  



  return (
    <group {...props} dispose={null}>
    <group
      position={[0.07143974, 4.89373159, 0.00855064]}
      scale={[0.01910445, 0.07881969, 0.31263703]}
    >
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061.geometry}
        material={materials["1"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_1.geometry}
        material={materials["Material.021"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_2.geometry}
        material={materials["Material.022"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_3.geometry}
        material={materials["Material.023"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_4.geometry}
        material={materials["Material.016"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_5.geometry}
        material={materials["preto.001"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_6.geometry}
        material={materials["Material.026"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_7.geometry}
        material={materials["Material.025"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_8.geometry}
        material={materials["Material.027"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_9.geometry}
        material={materials.verde}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_10.geometry}
        material={materials.mangera}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_11.geometry}
        material={materials.apoio}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_12.geometry}
        material={materials["Material.005"]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_13.geometry}
        material={materials.xd}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_14.geometry}
        material={materials.cabo}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_15.geometry}
        material={materials.MONITOR02}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_16.geometry}
        material={materials.borda}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_17.geometry}
        material={materiallight}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_18.geometry}
        material={material}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_19.geometry}
        material={materialcharger}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_20.geometry}
        material={materiallight2}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube061_21.geometry}
        material={materials.telav}
      />
    </group>
  </group>
  );
}

useGLTF.preload("./Chargers.glb");
