/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect  } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from 'three';
import { ShaderMaterial } from 'three';



export function ArvoreNatal(props) {
  const { nodes, materials } = useGLTF("./arvore_natal.glb");


  const material = new ShaderMaterial({
    side: THREE.DoubleSide,  // Adicione esta linha para renderizar de ambos os lados
    uniforms: {
      colorStart: { value: new THREE.Vector3(180, 180, 80) },
      colorEnd: { value: new THREE.Vector3(0, 0, 0) },
      time: { value: 0.0 },
    },
    vertexShader: `
      void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      uniform float time;
      uniform vec3 colorStart;
      uniform vec3 colorEnd;
  
      void main() {
        // Use a função sin para criar uma transição suave com fade in e fade out
        float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);
  
        // Interpole entre as cores de início e fim com base na transição
        vec3 color = mix(colorStart, colorEnd, transition);
  
        gl_FragColor = vec4(color, 1.0);
      }
    `,
  });
  
  const currentTimeRef = useRef(0);
    
    useEffect(() => {
      let animationFrameId;
    
      const updateMaterialTime = () => {
        const time = (performance.now() % 200) / 500;
        currentTimeRef.current = time;
        material.uniforms.time.value = time;
        animationFrameId = requestAnimationFrame(updateMaterialTime);
      };
    
      updateMaterialTime();
    
      return () => {
        cancelAnimationFrame(animationFrameId);
      };
    },  [material]); // Executa apenas uma vez ao montar o componente

    const material2 = new ShaderMaterial({
      side: THREE.DoubleSide,  // Adicione esta linha para renderizar de ambos os lados
      uniforms: {
        colorStart: { value: new THREE.Vector3(5, 5, 10) },
        colorEnd: { value: new THREE.Vector3(10, 5,5) },
        time: { value: 0.0 },
      },
      vertexShader: `
        void main() {
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 colorStart;
        uniform vec3 colorEnd;
    
        void main() {
          // Use a função sin para criar uma transição suave com fade in e fade out
          float transition = clamp(sin(time * 3.14159265359), 0.0, 1.0);
    
          // Interpole entre as cores de início e fim com base na transição
          vec3 color = mix(colorStart, colorEnd, transition);
    
          gl_FragColor = vec4(color, 1.0);
        }
      `,
    });
    
    const currentTimeRef2 = useRef(0);
      
      useEffect(() => {
        let animationFrameId2;
      
        const updateMaterialTime = () => {
          const time = (performance.now() % 800) / 1000;
          currentTimeRef2.current = time;
          material2.uniforms.time.value = time;
          animationFrameId2 = requestAnimationFrame(updateMaterialTime);
        };
      
        updateMaterialTime();
      
        return () => {
          cancelAnimationFrame(animationFrameId2);
        };
      },  [material2]); // Executa apenas uma vez ao montar o componente
  
  
      
    
  
  

  return (
   <group {...props} dispose={null}>
      <group
        position={[0.06900676, 0, 7.02747059]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={0.92781061}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015.geometry}
          material={materials.cABO}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_1.geometry}
          material={materials.Cor1}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_2.geometry}
          material={material2}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_3.geometry}
          material={materials.cajado}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_4.geometry}
          material={materials.arve}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_5.geometry}
          material={materials.snow}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_6.geometry}
          material={materials.caule}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_7.geometry}
          material={material}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_8.geometry}
          material={materials.Cor3}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.BezierCurve015_9.geometry}
          material={materials.Cor2}
        />
      </group>
    </group>
  );
}

useGLTF.preload("./arvore_natal.glb");
